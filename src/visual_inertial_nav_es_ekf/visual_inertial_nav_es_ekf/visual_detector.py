#!/usr/bin/env python3
"""
Visual Detector Node with Camera-Based Detection

Two modes:
1. COLOR: Detects colored cylinders (red, green, blue, yellow)
2. ARUCO: Detects ArUco markers

Publishes range and bearing measurements to detected landmarks.

Configured for project_world.sdf:
- Camera: /camera topic, 1280x720, FOV=2.5rad
- Landmarks: 1.0m tall cylinders, 0.2m radius
- Colors: Pure RGB (red, green, blue, yellow)
"""

import rclpy
from rclpy.node import Node
from sensor_msgs.msg import Image
from geometry_msgs.msg import PointStamped
from cv_bridge import CvBridge
import cv2
import numpy as np
import math
import json


def load_color_landmarks(json_path: str) -> dict:
    """
    Load landmark configuration from JSON file.

    Args:
        json_path: Path to landmarks.json generated by generate_world.py

    Returns:
        Dictionary compatible with visual detector's self.color_landmarks format
    """
    with open(json_path, 'r') as f:
        data = json.load(f)

    color_landmarks = {}
    for lm in data['landmarks']:
        color_landmarks[lm['id']] = {
            'name': lm['name'],
            'lower': np.array(lm['lower'], dtype=np.uint8),
            'upper': np.array(lm['upper'], dtype=np.uint8),
            'position': np.array([lm['x'], lm['y'], lm['z']]),
        }

    return color_landmarks


class VisualDetector(Node):
    def __init__(self):
        super().__init__('visual_detector')

        # --- Parameters ---
        self.declare_parameter('mode', 'color')  # 'color' or 'aruco'
        self.declare_parameter('camera_topic', '/camera')  # Match SDF
        self.declare_parameter('fov', 2.5)  # 2.5 rad (~143°) from SDF
        self.declare_parameter('image_width', 1280)  # From SDF
        self.declare_parameter('image_height', 720)  # From SDF
        self.declare_parameter('noise_bearing', 0.02)
        self.declare_parameter('noise_range', 0.05)
        self.declare_parameter('known_landmark_height', 1.0)  # 1.0m cylinder height from SDF
        self.declare_parameter('known_landmark_diameter', 0.4)  # 0.2m radius = 0.4m diameter
        self.declare_parameter('camera_height', 0.103)  # 0.010 (base_footprint) + 0.093 (camera_link)
        self.declare_parameter('landmarks_file', '')  # Path to landmarks.json
        self.declare_parameter('min_contour_area', 100)  # Minimum blob area in pixels
        self.declare_parameter('max_range', 20.0)  # Maximum detection range
        self.declare_parameter('min_range', 0.5)  # Minimum detection range

        # Load parameters
        self.mode = self.get_parameter('mode').value
        camera_topic = self.get_parameter('camera_topic').value
        self.fov = self.get_parameter('fov').value
        self.img_width = self.get_parameter('image_width').value
        self.img_height = self.get_parameter('image_height').value
        self.noise_bearing = self.get_parameter('noise_bearing').value
        self.noise_range = self.get_parameter('noise_range').value
        self.landmark_height = self.get_parameter('known_landmark_height').value
        self.landmark_diameter = self.get_parameter('known_landmark_diameter').value
        self.camera_height = self.get_parameter('camera_height').value
        self.min_contour_area = self.get_parameter('min_contour_area').value
        self.max_range = self.get_parameter('max_range').value
        self.min_range = self.get_parameter('min_range').value
        # Focal length from FOV: fx = (width/2) / tan(fov/2)
        self.fx = self.img_width / (2 * math.tan(self.fov / 2))
        self.fy = self.fx  # Assuming square pixels
        self.cx = self.img_width / 2
        self.cy = self.img_height / 2




        # Load landmarks
        landmarks_file = self.get_parameter('landmarks_file').value

        if landmarks_file:
            try:
                self.color_landmarks = load_color_landmarks(landmarks_file)
                self.get_logger().info(f"Loaded {len(self.color_landmarks)} landmarks from {landmarks_file}")
            except Exception as e:
                self.get_logger().error(f"Failed to load landmarks from {landmarks_file}: {e}")
                self.color_landmarks = self._default_landmarks()
        else:
            self.get_logger().warn("No landmarks_file specified, using defaults")
            self.color_landmarks = self._default_landmarks()

        # Log loaded landmarks
        for lm_id, info in self.color_landmarks.items():
            self.get_logger().info(
                f"  Landmark {lm_id}: {info['name']} "
                f"HSV=[{info['lower'][0]}-{info['upper'][0]}, "
                f"{info['lower'][1]}-{info['upper'][1]}, "
                f"{info['lower'][2]}-{info['upper'][2]}]"
            )

        # ArUco setup
        if self.mode == 'aruco':
            self.aruco_dict = cv2.aruco.getPredefinedDictionary(cv2.aruco.DICT_4X4_50)
            self.aruco_params = cv2.aruco.DetectorParameters()
            self.aruco_detector = cv2.aruco.ArucoDetector(self.aruco_dict, self.aruco_params)
            self.marker_size = 0.2  # meters

        # CV Bridge
        self.bridge = CvBridge()

        # Subscriber - use configured camera topic
        self.image_sub = self.create_subscription(
            Image, camera_topic, self.image_callback, 10
        )

        # Publisher
        self.measurement_pub = self.create_publisher(PointStamped, '/visual_measurement', 10)

        # Debug image publisher
        self.debug_pub = self.create_publisher(Image, '/visual_detector/debug_image', 10)

        self.get_logger().info(f"Visual Detector initialized in '{self.mode}' mode")
        self.get_logger().info(f"  Camera topic: {camera_topic}")
        self.get_logger().info(f"  FOV: {math.degrees(self.fov):.1f}°, Resolution: {self.img_width}x{self.img_height}")
        self.get_logger().info(f"  Focal length: fx={self.fx:.1f}, fy={self.fy:.1f}")
        self.get_logger().info(f"  Landmark height: {self.landmark_height}m, diameter: {self.landmark_diameter}m")

    def _default_landmarks(self):
        """
        Default landmark color definitions for project_world.sdf
        
        SDF uses pure RGB colors which map to HSV as follows (OpenCV uses H:0-180):
        - Red:    RGB(1,0,0) → HSV(0, 255, 255)   - H wraps around 0/180
        - Green:  RGB(0,1,0) → HSV(60, 255, 255)  - H=60 in OpenCV
        - Blue:   RGB(0,0,1) → HSV(120, 255, 255) - H=120 in OpenCV
        - Yellow: RGB(1,1,0) → HSV(30, 255, 255)  - H=30 in OpenCV
        
        We use wide ranges to account for lighting variations.
        """
        return {
            # Red: H wraps around 0, need two ranges (handled separately)
            # Primary range: H=0-10
            1: {
                'name': 'Red',
                'lower': np.array([0, 100, 100], dtype=np.uint8),
                'upper': np.array([10, 255, 255], dtype=np.uint8),
                'position': np.array([6.0, 6.0, 0.5]),
            },
            # Green: H=60 in OpenCV (pure green)
            2: {
                'name': 'Green',
                'lower': np.array([35, 100, 100], dtype=np.uint8),
                'upper': np.array([85, 255, 255], dtype=np.uint8),
                'position': np.array([6.0, -6.0, 0.5]),
            },
            # Blue: H=120 in OpenCV (pure blue)
            3: {
                'name': 'Blue',
                'lower': np.array([100, 100, 100], dtype=np.uint8),
                'upper': np.array([140, 255, 255], dtype=np.uint8),
                'position': np.array([10.0, 0.0, 0.5]),
            },
            # Yellow: H=30 in OpenCV (between red and green)
            4: {
                'name': 'Yellow',
                'lower': np.array([20, 100, 100], dtype=np.uint8),
                'upper': np.array([35, 255, 255], dtype=np.uint8),
                'position': np.array([0.0, 8.0, 0.5]),
            },
        }

    def image_callback(self, msg: Image):
        # Convert ROS Image to OpenCV
        try:
            cv_image = self.bridge.imgmsg_to_cv2(msg, desired_encoding='bgr8')
        except Exception as e:
            self.get_logger().error(f"CV Bridge error: {e}")
            return

        # Update actual image dimensions if different from parameters
        actual_h, actual_w = cv_image.shape[:2]
        if actual_w != self.img_width or actual_h != self.img_height:
            self.img_width = actual_w
            self.img_height = actual_h
            self.fx = self.img_width / (2 * math.tan(self.fov / 2))
            self.fy = self.fx
            self.cx = self.img_width / 2
            self.cy = self.img_height / 2
            self.get_logger().info(
                f"Updated image size: {self.img_width}x{self.img_height}, fx={self.fx:.1f}",
                throttle_duration_sec=5.0
            )

        if self.mode == 'color':
            self.detect_color_landmarks(cv_image, msg.header.stamp)
        elif self.mode == 'aruco':
            self.detect_aruco_markers(cv_image, msg.header.stamp)

    def detect_color_landmarks(self, image, stamp):
            """Detect colored cylinder landmarks with sub-pixel precision and robust filtering"""
            hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
            debug_image = image.copy()

            for lm_id, color_info in self.color_landmarks.items():
                # Create mask
                mask = cv2.inRange(hsv, color_info['lower'], color_info['upper'])

                if lm_id == 1:  # Red wrap-around
                    mask_upper = cv2.inRange(hsv, np.array([170, 100, 100]), np.array([180, 255, 255]))
                    mask = cv2.bitwise_or(mask, mask_upper)

                # --- FIX 1: Cleaner Morphology (No Dilation) ---
                # Using only Open/Close to clean noise without inflating the object size
                kernel = np.ones((3, 3), np.uint8)
                mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel, iterations=1)
                mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel, iterations=1)

                # Find contours
                contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
                if not contours:
                    continue

                # Get largest contour
                largest = max(contours, key=cv2.contourArea)
                area = cv2.contourArea(largest)

                if area < self.min_contour_area:
                    continue

                # --- FIX 2: Integer BBox for Border Rejection & Debug Drawing ---
                x, y, bbox_w, bbox_h = cv2.boundingRect(largest)

                # Reject if touching the border (clipped objects cause range errors)
                border_margin = 2
                if (x <= border_margin or y <= border_margin or 
                    (x + bbox_w) >= self.img_width - border_margin or 
                    (y + bbox_h) >= self.img_height - border_margin):
                    continue 

                # --- FIX 3: Sub-pixel Precision (Float) for Range Calculation ---
                rect = cv2.minAreaRect(largest)
                (center_x, center_y), (rect_w, rect_h), angle = rect
                
                # Determine which dimension is height (cylinders are tall)
                bbox_h_float = max(rect_w, rect_h)
                
                # Simple aspect ratio check (using floats)
                bbox_w_float = min(rect_w, rect_h)
                aspect_ratio = bbox_w_float / bbox_h_float if bbox_h_float > 0 else 0
                if aspect_ratio > 2.0:
                    continue

                # --- FIX 4: Centroid for Bearing (Less Jittery) ---
                M = cv2.moments(largest)
                if M["m00"] > 0:
                    cx_moment = M["m10"] / M["m00"]
                    bearing = self.pixel_to_bearing(cx_moment)
                else:
                    bearing = self.pixel_to_bearing(center_x)

                # --- FIX 5: Rectilinear Correction ---
                # No -5 subtraction needed anymore because we removed dilation!
                # We multiply by cos(bearing) to correct for flat-plane projection distortion
                corrected_h = bbox_h_float * math.cos(bearing)
                
                range_est = self.estimate_range_from_height(corrected_h)

                if range_est is None or not (self.min_range < range_est < self.max_range):
                    continue

                # Add noise (Optional: Keep 0.0 in launch file to test accuracy)
                noisy_bearing = bearing + np.random.normal(0, self.noise_bearing)
                noisy_range = range_est + np.random.normal(0, self.noise_range)
                noisy_range = max(0.1, noisy_range)

                # Publish measurement
                self.publish_measurement(noisy_bearing, noisy_range, lm_id, stamp)

                # --- DEBUG DRAWING (Now works because x, y, bbox_w, bbox_h are defined) ---
                cv2.rectangle(debug_image, (x, y), (x + bbox_w, y + bbox_h), (0, 255, 0), 2)
                cv2.putText(
                    debug_image,
                    f"{color_info['name']} r={range_est:.2f}m",
                    (x, y - 10),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 2
                )

                self.get_logger().info(
                    f"Detected {color_info['name']} (ID {lm_id}): "
                    f"bearing={math.degrees(bearing):.1f}°, range={range_est:.2f}m, "
                    f"bbox={bbox_w}x{bbox_h}, area={area}",
                    throttle_duration_sec=0.5
                )

            self.publish_debug_image(debug_image, stamp)


    def pixel_to_bearing(self, pixel_x):
        """
        Convert pixel x-coordinate to bearing angle.
        
        Bearing = 0 at center, positive = left, negative = right
        (Robot convention: positive rotation is counter-clockwise)
        """
        return math.atan2(self.cx - pixel_x, self.fx)

    def estimate_range_from_height(self, pixel_height):
        """
        Estimate range from apparent height of landmark.
        
        Using pinhole camera model:
        range = (real_height * focal_length) / pixel_height
        """
        if pixel_height < 5:
            return None
        return (self.landmark_height * self.fy) / pixel_height

    def estimate_range_from_width(self, pixel_width):
        """Estimate range from apparent width of landmark (diameter)"""
        if pixel_width < 5:
            return None
        return (self.landmark_diameter * self.fx) / pixel_width

    def estimate_range_from_marker_size(self, pixel_width):
        """Estimate range from ArUco marker apparent size"""
        if pixel_width < 5:
            return None
        return (self.marker_size * self.fx) / pixel_width

    def publish_measurement(self, bearing, range_val, landmark_id, stamp):
        """Publish visual measurement"""
        msg = PointStamped()
        msg.header.stamp = stamp
        msg.header.frame_id = 'camera_link'
        msg.point.x = float(bearing)
        msg.point.y = float(range_val)
        msg.point.z = float(landmark_id)
        self.measurement_pub.publish(msg)

    def publish_debug_image(self, image, stamp):
        """Publish debug image for visualization"""
        try:
            debug_msg = self.bridge.cv2_to_imgmsg(image, encoding='bgr8')
            debug_msg.header.stamp = stamp
            self.debug_pub.publish(debug_msg)
        except Exception as e:
            self.get_logger().error(f"Debug image publish error: {e}")


def main():
    rclpy.init()
    node = VisualDetector()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()